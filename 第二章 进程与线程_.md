## 进程

- 进程模型
    
    - 一个进程就是一个正在执行的程序
    - 进程包括程序计数器（PC）、寄存器、变量的当前值等等
    - CPU可以在不同进程之间来回切换——多进程，但是任何时刻总是只有一个进程在运行
- 进程的创建
    
    - 四种主要事件会导致进程的创建
        - 系统初始化
        - 正在运行的程序执行了创建进程的系统调用
        - 用户请求创建一个进程
        - 一个批处理作业的初始化
    - 子进程的地址空间的内容和父进程完全一样，
    - 所有进程创建的本质都是因为一个现有进程执行了**fork**
    - 子进程创建之后，会执行**execve**来执行别的程序
- 进程的终止
    
    - 四种主要事件会导致进程的终止
        - 正常退出（自愿）
        - 出错退出（自愿）
        - 严重错误（非自愿）
        - 被其他进程杀死（非自愿）
    - 进程的层次结构
        - UNIX系统中，进程创建另一个进程后，父进程和子进程就以某种形式继续保持联系；进程只有一个父进程，但可以有多个子进程
        - Windows中没有进程层次的概念，所有进程都是地位相等的，但父进程创建子进程后会得到一个令牌（称为句柄）；句柄可以用来控制子进程，但父进程有权把这个令牌传递给其他进程，这样，就不存在层次概念了
- 进程的状态
    
    - 就绪
    - 运行
    - 阻塞
- 进程的实现
    
    - 操作系统维护一张进程表，每个进程占用一个进程表项
    - 每个I/O设备都有一个[中断向量](https://xingqijiang.blog.csdn.net/article/details/50121197?spm=1001.2101.3001.6661.1&utm_medium=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7EPayColumn-1.pc_relevant_default&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7EPayColumn-1.pc_relevant_default&utm_relevant_index=1)，保存着中断服务的地址
    - 发生中断后进程的所有信息都被终止硬件保存到栈中，然后计算机跳转到中断向量指向的地址

## 线程

一个进程包含一个线程，对现在的系统而言，通常有多个线程

- 线程的使用
    
    - 多线程是在多进程的基础上继续的演化来的， 都是为了提升CPU的利用率，因为CPU是一种很宝贵的资源，因减少浪费。假设一个进程要执行三道数学题，如果没有线程的概念，那这个进程只能一道一道的去完成，执行第一道产生I/O操作时，就会阻塞，知道阻塞完成了才会继续执行。这样效率就比较低，而如果有了多个线程，每个线程执行一道数学题，互不干扰，这个线程就可以一直处于运行状态，抢到时间片的几率就大了，就可不断执行。并且，如果当前运行进程少或者其他进程也在阻塞，那没人用CPU，就是一种浪费，所以多线程可以尽量减少进程的阻塞，从而可以让CPU一直有事可做。当然，这只是一种比喻。 还有就是，进程切换的开销远大于线程切换的开销，毕竟，线程切换都是在同一个进程中
- 经典的线程模型
    
    - 进程间的线程不像同进程那样有很大独立性，所有线程有完全一样的地址空间，共享同样的全局变量，因此没有跨进程通信的麻烦
    - 每个进程的数据、打开的资源、文件、代码都是相同的，每个线程都可以取用，但是每个线程都有自己的的程序计数器、寄存器、堆栈等
    - 同一进程下面的不同线程之间没有保护
    - 存在问题
        - 如果一个线程关掉了一个文件而别的线程在使用这个文件？
        - 如果process fork了一个新的进程，新的进程是否复制原有进程的所有线程？
- 用户线程和内核线程
    
    - 用户线程
        - 在用户空间实现线程，内核对线程一无所知， 内核依然按照老的方式，把进程当做单线程进程
        - 优点
            - 线程切换不用陷入内核，不需要上下文切换，所以线程切换速度很快
            - 允许每个进程有自己定制的调度算法
        - 缺点
            - 在如何实现阻塞系统调用上实现有困难，而如果采用非阻塞方案，需要修改原有的操作系统
            - 如果一个线程开始运行，那么该进程中其他线程就无法运行，除非第一个线程放弃CPU，那么线程的调度又是一个问题
    - 内核线程
        - 在内核空间实现线程
        - 为了节约时间开销——销毁线程时只是标记为不可用，而不回收空间和内容
    - 实际上——在内核空间中维持线程，然后在这些的基础上在用户空间对这些内核线程进行多路复用
- [内核调度机制](https://www.codenong.com/cs105549070/)
    
    - 实际上就是让内核层和用户层之间有更多的交流，使内核更多地接入到用户空间的线程中？
- 弹出线程
    
    - 以服务器接受请求为例
        - 可以用已有的线程去，处理这样的一个请求
        - 也可以新生成一个线程来处理（弹出线程）
        - 弹出线程的优缺点
            - 减少了从收到信息到开始处理这一过程中的延迟
            - 如果运行在内核态，一个有bug的线程会造成更大的损失
- 多线程
    
    - 全局变量共享的问题
    - 内存分配的问题
    - 信号读取的问题
    - 栈溢出的问题

## 进程间通信

- 进程间通信主要围绕三个核心问题
    
    - 如何把信息传递给另一个进程
    - 如何确保两个或多个进程不会交叉（例如多个用户在飞机订票系统同时取买票，该给谁）
    - 如何确保按正确的顺序执行——如果B进程要打印A进程的结果，那么肯定是先执行完A，才能执行B
- 竞争条件（Race Condition）& 临界区（Critical Region）
    
    - 多个进程同时读写某些共享数据，就存在竞争
    - 多个进程同时需要访问的**程序片段**称为临界区
- 为了避免竞争并且保证并行程序的正确性和效率，需要满足一下条件：
    
    - 任何两个进程不能同时处于临界区
    - 与CPU的速度和数量无关
    - 临界区外的进程不得阻塞其他进程
    - 进程不能无限期等待
- 互斥（通过忙等实现）
    
    - 互斥（Mutual Exclusion）——散布在不同进程的代码片段，当某个进程访问了其中一个片段时，此时其他进程就不能访问了，只能等该进程结束后才可访问
        
    - 同步（Synchronization）——散布在不同进程之间的若干程序片断，它们的运行必须严格按照规定的 某种先后次序来运行，这种先后次序依赖于要完成的特定的任务
        
    - 互斥的实现方案
        
        - 屏蔽中断（Disabling Interrupts）
            
            - 在一个用户进程执行的时候屏蔽来自CPU的中断信号
            - 显然不妥当（如果用户进程一直不停止？）
            - 对于多核系统，屏蔽中断不能够屏蔽来自其他CPU核的interrupt指令
        - 锁变量
            
            - 当一个进程要访问临界区时，如果锁变量是1，有进程在临界区中，等待改进程结束并且把锁变量置为0；如果锁变量是0，就可以进入临界区
            - 但是不能避免竞争——当进程**A**读取到lock为0而还没有将其设为1时，另一进程**B**开始运行，并且把lock设为1，这种情况下**A**重新开始运行时也会进入临界区，而这个时候**B**可能也在里面
        - 严格轮换法
            
            - 简单来说，就是**A**用完了发信号，表明自己不用了，然后**B**来用，但是如果**B**不用，那么**A**也无法使用
            - 用到了忙等——占用CPU
        - Peterson方法
            
            - 实质上是轮换法，但是做出了一定的优化，避免轮换法存在的问题
                
            - 详情可以体会一下下面的这段算法，因为感觉简单但是占篇幅，不展开了
                
            - ```C
                    void enter region(int process); /* process is 0 or 1 */
                    {
                        int other; /* number of the other process */
                        other = 1 − process; /* the opposite of process */
                        interested[process] = TRUE; /* show that you are interested */
                        turn = process; /* set flag */
                        while (turn == process && interested[other] == TRUE) /* null statement */ ;
                    }
                    void leave region(int process) /* process: who is leaving */
                    {
                        interested[process] = FALSE; /* indicate departure from critical region */
                    }
                ```
                
        - TSL指令——硬件支持的方案
            
            - TSL——Test and Set Lock
            - 思想很简单——把检查lock是否可用和设置lock的值作为一个原子指令，这样CPU就无法中断这一过程了
            - TSL指令将 内存自LOCK读到寄存器RX中，然后在该内存地址上存在一个非零值。读字和写字由操作系统保证是不可分割的（原子性），CPU将锁住内存总线（这样子可以完全避免别的CPU的interrupt）
            - 也可以用XCHG（exchange）指令，XCHG改变两个地址对应的内容
        - Perterson解法和TSL/XCHG解法都是正确可行的他们的本质都是：当一个进程想进入临界区，先检查是否允许进入，若不允许则原地等待，直到允许为止，但是都存在问题：
            
            - 浪费CPU工作时间
            - 可能存在优先级颠倒问题
                - Consider a computer with two processes, H, with high priority, and L, with
                    low priority. The scheduling rules are such that H is run whenever it is in ready
                    state. At a certain moment, with L in its critical region, H becomes ready to run
                    (e.g., an I/O operation completes). H now begins busy waiting, but since L is never
                    scheduled while H is running, L never gets the chance to leave its critical region, so
                    H loops forever. This situation is sometimes referred to as the priority inversion
                    problem
    - 进程的睡眠和唤醒
        
        - 消费者——生产者问题
            - 就是有的程序从缓存里面拿数据，有的程序写数据，如果写满了就不写，如果是空的就不取——这样会存在竞争
        - 信号量
            - 将检查值、修改值以及可能发生的睡眠操作作为一个单一的、不可分割的**原子**操作完成，原子性由操作系统保证。在完成前，其他进程不允许访问信号量
            - 支持的操作——down，up，就是把拿/放数据并修改计数器（缓存的内容数）放到一起去
            - 需要使用如TSL或XCHG之类的硬件支持指令
            - 通常是采用system call来实现down和up，这样可以在使用信号量时禁用所有的中断
        - 互斥量
            - 信号量的简化版本，不需要计数能力，一般用于用户层的线程包中，只需要两种状态：解锁和加锁。一个二进制位就可表示它，不过通常用整型
            - 没有访问资格的线程被阻塞，当多个线程被阻塞时，会随机选择一个执行
            - 支持三种操作
                - mutex_lock——获取锁，如果没有获取，阻塞当前线程
                - mutex_unlock——释放锁
                - mutex_trylock——这条指令在线程没有获得锁的时候不会阻塞原线程，这样可以使原线程自由处理这种情况
            - 如果几个线程拥有不同的地址空间，如何共享信号量或互斥量或Perterson中的turn变量？
                - 将这些内容存在内核中，并且用系统调用来访问
                - 现代操作系统允许进程去分享他们的部分地址空间
        - futexes
            - fast user space metux
            - [Resource](https://blog.csdn.net/jianchaolv/article/details/7544316)
        - 管程
            - [Resource](https://blog.csdn.net/qq_40949465/article/details/88703441)
    - 同步原语
        
        - 保证同步执行的代码语句。大致理解为只有将同步的代码执行完毕，才能顺序执行下一段代码
    - 屏障
        
        - 通常用于进程组，把他们的执行划分了不同阶段，每个阶段末尾设置一个屏障，只有所有进程都到达屏障，才能继续运行下一个阶段
- RCU（Read-Copy Update)
    
    - 读-拷贝修改
    - 对于被RCU保护的共享数据结构，读操作不需要获得任何锁就可以访问，但写操作在访问它时首先拷贝一个副本，然后对副本进行修改，最后在适当的时机把指向原来数据的指针重新指向新的被修改的数据。这个时机就是所有引用该数据的CPU都退出对共享数据的操作

## 调度

- 调度——当多个进程同时竞争CPU时，由调度程序来选择一个进程执行
- 进程切换——占用CPU资源的使用者发生了切换。需要保存当前进程在PCB（进程控制块）的执行上下文（寄存器、数据、打开资源文件等），然后恢复下一个进程的上下文
- 何时进行调度
    - 抢占式系统
        - 调度算法挑一个进程，让其运行固定的最大时间周期，如果时间到了还在运行，则挂起等待下一次运行，然后切换下一个进程
    - 非抢占式系统
        - 调度算法挑一个去运行，直到该进程阻塞或自动释放CPU
- 调度算法的目标
    - 对于所有系统
        - 公平
        - 强制力
        - 平衡（系统各个模块的占用）
    - 批处理系统
        - 最大完成任务数
        - 完成单个任务需要的时间
        - CPU利用率
    - 交互式系统
        - 反应时间
        - 均衡性（满足用户的期望）
    - 实时系统
        - 满足截止时间（避免丢失数据）
        - 可预测性（在多媒体系统中避免品质降低）
- 批处理系统中的调度算法
    - FCFS(First Come First Serve)
        - 按照请求CPU的顺序使用CPU
    - Shortest Job First
        - 谁的运行时间短，谁先执行，好处是每个作业的平均等待时间短。如两个进程，A需要运行20分钟,B两分钟，如果先运行A,则B等待20分钟，总的等待20分钟，平均等待10分钟；如果先运行B，在运行A，则A等待2分钟，总的等待2分钟，平均等待一分钟
    - Shortest Remaining Time Next
        - 也是抢占式的，每次找到剩余执行最短的程序执行，给其固定的运行时间，如果到期还没运行完毕，则进入就绪队列等待
- 交互式系统的调度算法
    - 轮转调度
        - 也就是大家轮流来，一个进程分配固定时间片，时间到了还没执行完，则移动到就绪队列队尾，下一个进程接着来
    - 优先级调度
        - 优先级高的进程先运行，统一优先级的则按照轮转调度
    - 多级队列
        - 举个例子，高优先级的进程先运行一个时间片，然后是次高级队列每个进程运行2个时间片，然后再次一级运行四个时间片。每个进程运行一次后，优先级降低一级
    - 最短进程优先
        - 每次执行预计执行时间最短的进程
        - 如何预计进程执行时间？
            - 根据过去的执行时间做预估，给予过去的执行时间一定的权值
    - 保证调度
        - 对于多个用户来说，保证每个用户享有同样比例的资源（也可以不一样，就是一定比例）
    - 彩票调度
        - 按比例分配彩票，每次随机选一个彩票号码执行
        - 重要的或者给予更多资源的进程，就分配更多彩票
    - 公平分享调度
        - 考虑到进程所属的用户进行调度
- 实时系统的调度算法
    - 可以根据是否一定要满足截止时间分为硬实时和软实时
    - 实际上好像没有太多内容（懒）
- 调度策略与机制分离
    - 将调度算法以某种形式参数化，具体参数由用户进程写入。调度机制位于内核，调度策略可由用户进程决定
    - 这样可以使操作系统可以给某个线程的子线程分配适当的资源
- 线程调度
    - 用户态线程&内核态线程
    - 下面这张图应该能够比较好的说明问题了：
    - ![20a633edbef40e6c15bba9d4cebc0c93.png](../_resources/20a633edbef40e6c15bba9d4cebc0c93.png)

## 传统的进程间通信问题

- [吃饭的哲学家问题](https://blog.csdn.net/low5252/article/details/104800671)
- [读者和写者问题](https://blog.csdn.net/weixin_44827418/article/details/106195361)

* * *

写完啦！至少是糊完啦！颇为不容易呢

要好好努力了！